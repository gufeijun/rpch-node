// This is code generated by hgen. DO NOT EDIT!!!
// hgen version: v0.1.6
// source: math.gfj

'use strict';

class MathInterface {
	// arg1: uint32
	// arg2: uint32
	// ret:  uint32
	async Add(arg1, arg2) {
		throw "No implementation";
	}
	// arg1: int32
	// arg2: int32
	// ret:  int32
	async Sub(arg1, arg2) {
		throw "No implementation";
	}
	// arg1: TwoNum
	// ret:  int32
	async Multiply(arg1) {
		throw "No implementation";
	}
	// arg1: uint64
	// arg2: uint64
	// ret:  Quotient
	async Divide(arg1, arg2) {
		throw "No implementation";
	}
};

function MathAddHandler(impl) {
	return async args => {
        if (args.length != 2) throw "invalid argument cnt";
		if (args[0].name != "uint32" || args[0].data.length != 4) throw "invalid type";
		if (args[1].name != "uint32" || args[1].data.length != 4) throw "invalid type";
		let arg0 = Number(args[0].data.readUInt32LE());
		let arg1 = Number(args[1].data.readUInt32LE());
		let res = await impl.Add(arg0, arg1);
		let data = Buffer.alloc(4);
		data.writeUInt32LE(res);
		let resp = {
			typeKind: 0,
			name: "uint32",
			data: data,
		};
		return resp;
	};
}

function MathSubHandler(impl) {
	return async args => {
        if (args.length != 2) throw "invalid argument cnt";
		if (args[0].name != "int32" || args[0].data.length != 4) throw "invalid type";
		if (args[1].name != "int32" || args[1].data.length != 4) throw "invalid type";
		let arg0 = Number(args[0].data.readInt32LE());
		let arg1 = Number(args[1].data.readInt32LE());
		let res = await impl.Sub(arg0, arg1);
		let data = Buffer.alloc(4);
		data.writeInt32LE(res);
		let resp = {
			typeKind: 0,
			name: "int32",
			data: data,
		};
		return resp;
	};
}

function MathMultiplyHandler(impl) {
	return async args => {
        if (args.length != 1) throw "invalid argument cnt";
		if (args[0].name != "TwoNum") throw "invalid type";
		let arg0 = JSON.parse(args[0].data.toString());
		let res = await impl.Multiply(arg0);
		let data = Buffer.alloc(4);
		data.writeInt32LE(res);
		let resp = {
			typeKind: 0,
			name: "int32",
			data: data,
		};
		return resp;
	};
}

function MathDivideHandler(impl) {
	return async args => {
        if (args.length != 2) throw "invalid argument cnt";
		if (args[0].name != "uint64" || args[0].data.length != 8) throw "invalid type";
		if (args[1].name != "uint64" || args[1].data.length != 8) throw "invalid type";
		let arg0 = Number(args[0].data.readBigUInt64LE());
		let arg1 = Number(args[1].data.readBigUInt64LE());
		let res = await impl.Divide(arg0, arg1);
		
		let resp = {
			typeKind: 2,
			name: "Quotient",
			data: JSON.stringify(res),
		};
		return resp;
	};
}

function checkImplements(impl, service, methods) {
    methods.forEach(method => {
        if (impl[method] == undefined)
            throw `should implement method ${method} for service ${service}`;
    })
}

function registerMathService(svr, impl) {
	checkImplements(impl, "Math", ["Add", "Sub", "Multiply", "Divide"]);
	svr.register({
		name: "Math",
		methods: {
			Add: MathAddHandler(impl),
			Sub: MathSubHandler(impl),
			Multiply: MathMultiplyHandler(impl),
			Divide: MathDivideHandler(impl),
		}
	});
}

class MathClient {
	constructor(conn) {
		this.conn = conn;
		this.service = "Math";
	}
	
	// arg1: uint32
	// arg2: uint32
	// ret:  uint32
	async Add(arg1, arg2) {
		let req = {
			service: this.service,
			method: "Add",
			argCnt: 2,
			args: [],
		};
		let buf1 = Buffer.alloc(4)
		buf1.writeUInt32LE(arg1)
		req.args.push({
            typeKind: 0,
            name: 'uint32',
            data: buf1,
        })
		let buf2 = Buffer.alloc(4)
		buf2.writeUInt32LE(arg2)
		req.args.push({
            typeKind: 0,
            name: 'uint32',
            data: buf2,
        })
        return new Promise((resolve, reject) => {
            this.conn.call(req, (resp, err) => {
                if (err != null) {
                    reject(err);
                    return;
                }
				if (resp.name != "uint32" || resp.dataLen != 4){
					reject(new Error("invalid response type"));
					return;
				}
				resolve(Number(resp.data.readUInt32LE()));
            })
        })
	}
	
	// arg1: int32
	// arg2: int32
	// ret:  int32
	async Sub(arg1, arg2) {
		let req = {
			service: this.service,
			method: "Sub",
			argCnt: 2,
			args: [],
		};
		let buf1 = Buffer.alloc(4)
		buf1.writeInt32LE(arg1)
		req.args.push({
            typeKind: 0,
            name: 'int32',
            data: buf1,
        })
		let buf2 = Buffer.alloc(4)
		buf2.writeInt32LE(arg2)
		req.args.push({
            typeKind: 0,
            name: 'int32',
            data: buf2,
        })
        return new Promise((resolve, reject) => {
            this.conn.call(req, (resp, err) => {
                if (err != null) {
                    reject(err);
                    return;
                }
				if (resp.name != "int32" || resp.dataLen != 4){
					reject(new Error("invalid response type"));
					return;
				}
				resolve(Number(resp.data.readInt32LE()));
            })
        })
	}
	
	// arg1: TwoNum
	// ret:  int32
	async Multiply(arg1) {
		let req = {
			service: this.service,
			method: "Multiply",
			argCnt: 1,
			args: [],
		};
		req.args.push({
            typeKind: 2,
            name: 'TwoNum',
            data: JSON.stringify(arg1),
        })
        return new Promise((resolve, reject) => {
            this.conn.call(req, (resp, err) => {
                if (err != null) {
                    reject(err);
                    return;
                }
				if (resp.name != "int32" || resp.dataLen != 4){
					reject(new Error("invalid response type"));
					return;
				}
				resolve(Number(resp.data.readInt32LE()));
            })
        })
	}
	
	// arg1: uint64
	// arg2: uint64
	// ret:  Quotient
	async Divide(arg1, arg2) {
		let req = {
			service: this.service,
			method: "Divide",
			argCnt: 2,
			args: [],
		};
		let buf1 = Buffer.alloc(8)
		buf1.writeBigUInt64LE(BigInt(arg1))
		req.args.push({
            typeKind: 0,
            name: 'uint64',
            data: buf1,
        })
		let buf2 = Buffer.alloc(8)
		buf2.writeBigUInt64LE(BigInt(arg2))
		req.args.push({
            typeKind: 0,
            name: 'uint64',
            data: buf2,
        })
        return new Promise((resolve, reject) => {
            this.conn.call(req, (resp, err) => {
                if (err != null) {
                    reject(err);
                    return;
                }
				if (resp.name != "Quotient"){
					reject(new Error("invalid response type"));
					return;
				}
				resolve(JSON.parse(resp.data.toString()));
            })
        })
	}
}

module.exports = {
	registerMathService,
	MathInterface,
	MathClient,
}
