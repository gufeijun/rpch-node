// This is code generated by hgen. DO NOT EDIT!!!
// hgen version: v0.1.6
// source: string.gfj

'use strict';

class stringInterface {
	// arg1: string
	// ret:  string
	async toupper(arg1) {
		throw "No implementation";
	}
	// arg1: string
	// ret:  string
	async tolower(arg1) {
		throw "No implementation";
	}
	// arg1: string
	// arg2: string
	// ret:  string
	async concat(arg1, arg2) {
		throw "No implementation";
	}
	// arg1: string
	// ret:  int32
	async atoi(arg1) {
		throw "No implementation";
	}
};

function stringtoupperHandler(impl) {
	return async args => {
        if (args.length != 1) throw "invalid argument cnt";
		if (args[0].name != "string") throw "invalid type";
		let arg0 = args[0].data.toString();
		let res = await impl.toupper(arg0);
		
		let resp = {
			typeKind: 0,
			name: "string",
			data: res,
		};
		return resp;
	};
}

function stringtolowerHandler(impl) {
	return async args => {
        if (args.length != 1) throw "invalid argument cnt";
		if (args[0].name != "string") throw "invalid type";
		let arg0 = args[0].data.toString();
		let res = await impl.tolower(arg0);
		
		let resp = {
			typeKind: 0,
			name: "string",
			data: res,
		};
		return resp;
	};
}

function stringconcatHandler(impl) {
	return async args => {
        if (args.length != 2) throw "invalid argument cnt";
		if (args[0].name != "string") throw "invalid type";
		if (args[1].name != "string") throw "invalid type";
		let arg0 = args[0].data.toString();
		let arg1 = args[1].data.toString();
		let res = await impl.concat(arg0, arg1);
		
		let resp = {
			typeKind: 0,
			name: "string",
			data: res,
		};
		return resp;
	};
}

function stringatoiHandler(impl) {
	return async args => {
        if (args.length != 1) throw "invalid argument cnt";
		if (args[0].name != "string") throw "invalid type";
		let arg0 = args[0].data.toString();
		let res = await impl.atoi(arg0);
		let data = Buffer.alloc(4);
		data.writeInt32LE(res);
		let resp = {
			typeKind: 0,
			name: "int32",
			data: data,
		};
		return resp;
	};
}

function checkImplements(impl, service, methods) {
    methods.forEach(method => {
        if (impl[method] == undefined)
            throw `should implement method ${method} for service ${service}`;
    })
}

function registerstringService(svr, impl) {
	checkImplements(impl, "string", ["toupper", "tolower", "concat", "atoi"]);
	svr.register({
		name: "string",
		methods: {
			toupper: stringtoupperHandler(impl),
			tolower: stringtolowerHandler(impl),
			concat: stringconcatHandler(impl),
			atoi: stringatoiHandler(impl),
		}
	});
}

class stringClient {
	constructor(conn) {
		this.conn = conn;
		this.service = "string";
	}
	
	// arg1: string
	// ret:  string
	async toupper(arg1) {
		let req = {
			service: this.service,
			method: "toupper",
			argCnt: 1,
			args: [],
		};
		req.args.push({
            typeKind: 0,
            name: 'string',
            data: arg1,
        })
        return new Promise((resolve, reject) => {
            this.conn.call(req, (resp, err) => {
                if (err != null) {
                    reject(err);
                    return;
                }
				if (resp.name != "string"){
					reject(new Error("invalid response type"));
					return;
				}
				resolve(resp.data.toString());
            })
        })
	}
	
	// arg1: string
	// ret:  string
	async tolower(arg1) {
		let req = {
			service: this.service,
			method: "tolower",
			argCnt: 1,
			args: [],
		};
		req.args.push({
            typeKind: 0,
            name: 'string',
            data: arg1,
        })
        return new Promise((resolve, reject) => {
            this.conn.call(req, (resp, err) => {
                if (err != null) {
                    reject(err);
                    return;
                }
				if (resp.name != "string"){
					reject(new Error("invalid response type"));
					return;
				}
				resolve(resp.data.toString());
            })
        })
	}
	
	// arg1: string
	// arg2: string
	// ret:  string
	async concat(arg1, arg2) {
		let req = {
			service: this.service,
			method: "concat",
			argCnt: 2,
			args: [],
		};
		req.args.push({
            typeKind: 0,
            name: 'string',
            data: arg1,
        })
		req.args.push({
            typeKind: 0,
            name: 'string',
            data: arg2,
        })
        return new Promise((resolve, reject) => {
            this.conn.call(req, (resp, err) => {
                if (err != null) {
                    reject(err);
                    return;
                }
				if (resp.name != "string"){
					reject(new Error("invalid response type"));
					return;
				}
				resolve(resp.data.toString());
            })
        })
	}
	
	// arg1: string
	// ret:  int32
	async atoi(arg1) {
		let req = {
			service: this.service,
			method: "atoi",
			argCnt: 1,
			args: [],
		};
		req.args.push({
            typeKind: 0,
            name: 'string',
            data: arg1,
        })
        return new Promise((resolve, reject) => {
            this.conn.call(req, (resp, err) => {
                if (err != null) {
                    reject(err);
                    return;
                }
				if (resp.name != "int32" || resp.dataLen != 4){
					reject(new Error("invalid response type"));
					return;
				}
				resolve(Number(resp.data.readInt32LE()));
            })
        })
	}
}

module.exports = {
	registerstringService,
	stringInterface,
	stringClient,
}
